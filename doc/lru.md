### LRU算法
LRU(Least recently used)最近最少使用算法，是一种常用的缓存淘汰算法，主要思想就是将最近最少使用的数据淘汰掉，保留最近使用过的数据。
当缓存满了的时候，需要选择一种策略将部分缓存淘汰掉，LRU的出发点就是淘汰掉最近最少使用的那部分缓存。


#### 实现思路一
最简单的思路就是为每个缓存数据添加一个时间戳，用来记录最近一次访问的时间，当缓存满了的时候，淘汰数据时遍历所有缓存数据，选择时间戳最老的那个淘汰掉。
想法简单，但性能太差。代码可见[lru_time](../src/lru_time.rs)。

#### 实现思路二
双向链表实现思路： 每当新插入或者访问数据，将数据放到链表头部，当数据满了的时候，从链表尾部删除数据。

#### 实现思路三
哈希表+双向链表实现。主要思路是在双向链表的实现基础上，增加一个哈希表，用于索引key，使得插入和删除的复杂度降低到O(1)。
具体一点就是，哈希表的K可以认为是一个索引，V 是一个双向链表，每个V都有前驱节点和后驱节点的指针。其实这个思路和[linked-hash-map](https://github.com/contain-rs/linked-hash-map)的思路差不多。

### LRU算法优化



![image](lru.png)



> [LRU算法及其优化策略——算法篇](https://juejin.cn/post/6844904049263771662#heading-8)